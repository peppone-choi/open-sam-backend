/**
 * HandleAFK Service - AFK ê°ì§€ ë° AI ì œì–´
 * 
 * ê¸°ëŠ¥:
 * 1. í„´ë§ˆë‹¤ ëª…ë ¹ ì œì¶œ ì—¬ë¶€ í™•ì¸
 * 2. 3í„´ ì—°ì† ë¯¸ì œì¶œ â†’ AI ì œì–´ í™œì„±í™”
 * 3. AIê°€ ìë™ìœ¼ë¡œ ëª…ë ¹ ì œì¶œ
 * 4. ìœ ì € ë³µê·€ ì‹œ AI ì œì–´ í•´ì œ
 */

import { Battle } from '../../models/battle.model';

export interface AFKStatus {
  generalId: number;
  afkTurns: number;
  aiControlled: boolean;
  warning: boolean; // 2í„´ AFK â†’ ê²½ê³ 
}

export class HandleAFKService {
  /**
   * í„´ ì‹œì‘ ì‹œ AFK ì²´í¬
   * ëª…ë ¹ì„ ì œì¶œí•˜ì§€ ì•Šì€ ì¥ìˆ˜ë“¤ì˜ AFK ì¹´ìš´íŠ¸ ì¦ê°€
   */
  static async checkAFK(battleId: string): Promise<AFKStatus[]> {
    const battle = await (Battle as any).findOne({ battleId: battleId });
    if (!battle) {
      throw new Error(`ì „íˆ¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${battleId}`);
    }

    const afkStatuses: AFKStatus[] = [];
    const currentTurn = battle.current_turn;

    // ëª¨ë“  ì°¸ì—¬ ì¥ìˆ˜ í™•ì¸
    const allGeneralIds = [
      ...battle.attacker.generals,
      ...battle.defender.generals,
    ];

    for (const generalId of allGeneralIds) {
      let afkEntry = battle.afk_tracking.find((a) => a.general_id === generalId);

      // ì²« ì§„ì…
      if (!afkEntry) {
        afkEntry = {
          general_id: generalId,
          afk_turns: 0,
          ai_controlled: false,
        };
        battle.afk_tracking.push(afkEntry);
      }

      // í˜„ì¬ í„´ì—ì„œ ëª…ë ¹ ì œì¶œ ì—¬ë¶€ í™•ì¸
      const turnHistory = battle.turn_history.find((h) => h.turn === currentTurn);
      const hasSubmittedAction = turnHistory?.actions.some(
        (action: any) => action.generalId === generalId
      );

      if (!hasSubmittedAction) {
        // ëª…ë ¹ ë¯¸ì œì¶œ â†’ AFK ì¹´ìš´íŠ¸ ì¦ê°€
        afkEntry.afk_turns++;
      } else {
        // ëª…ë ¹ ì œì¶œ â†’ AFK ì¹´ìš´íŠ¸ ì´ˆê¸°í™”
        afkEntry.afk_turns = 0;
        afkEntry.ai_controlled = false;
      }

      // 3í„´ ì´ìƒ AFK â†’ AI ì œì–´ í™œì„±í™”
      if (afkEntry.afk_turns >= 3 && !afkEntry.ai_controlled) {
        afkEntry.ai_controlled = true;
        console.log(`[AFK] ì¥ìˆ˜ ${generalId} AI ì œì–´ í™œì„±í™” (${afkEntry.afk_turns}í„´ AFK)`);
      }

      afkStatuses.push({
        generalId,
        afkTurns: afkEntry.afk_turns,
        aiControlled: afkEntry.ai_controlled,
        warning: afkEntry.afk_turns === 2, // 2í„´ AFK â†’ ê²½ê³ 
      });
    }

    // DB ì—…ë°ì´íŠ¸
    await battle.save();

    return afkStatuses;
  }

  /**
   * AI ì œì–´ í™œì„±í™” ì—¬ë¶€ í™•ì¸
   */
  static async isAIControlled(
    battleId: string,
    generalId: number
  ): Promise<boolean> {
    const battle = await (Battle as any).findOne({ battleId: battleId }).exec();
    if (!battle) return false;

    const afkEntry = battle.afk_tracking.find((a) => a.general_id === generalId);
    return afkEntry?.ai_controlled || false;
  }

  /**
   * AIê°€ ìë™ìœ¼ë¡œ ëª…ë ¹ ìƒì„±
   * ê°„ë‹¨í•œ ì „ìˆ  AI:
   * 1. ê³µê²©ì: ê°€ì¥ ê°€ê¹Œìš´ ê±°ì ìœ¼ë¡œ ì´ë™
   * 2. ë°©ì–´ì: ê±°ì  ì¤‘ì‹¬ ë°©ì–´
   */
  static async generateAIAction(
    battleId: string,
    generalId: number
  ): Promise<any> {
    const battle = await (Battle as any).findOne({ battleId: battleId }).exec();
    if (!battle) {
      throw new Error(`ì „íˆ¬ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${battleId}`);
    }

    // ê³µê²©ìì¸ì§€ ë°©ì–´ìì¸ì§€ í™•ì¸
    const isAttacker = battle.attacker.generals.includes(generalId);

    // ì¥ìˆ˜ì˜ í˜„ì¬ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸° (TODO: ì‹¤ì œ ìœ„ì¹˜ ì¶”ì  í•„ìš”)
    // í˜„ì¬ëŠ” ê°„ë‹¨íˆ ëœë¤ ì´ë™
    const currentPos = this.getGeneralPosition(battle, generalId);

    if (isAttacker) {
      // ê³µê²©ì: ì¤‘ì•™ìœ¼ë¡œ ì§„ê²©
      return this.generateAttackerAction(currentPos);
    } else {
      // ë°©ì–´ì: ê±°ì  ë°©ì–´
      return this.generateDefenderAction(currentPos);
    }
  }

  /**
   * ì¥ìˆ˜ í˜„ì¬ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°
   */
  private static getGeneralPosition(battle: any, generalId: number): { x: number; y: number } {
    // FUTURE: ìœ ë‹› ìœ„ì¹˜ ì¶”ì  ì‹œìŠ¤í…œ í•„ìš”
    // í˜„ì¬ëŠ” ì„ì‹œë¡œ ê¸°ë³¸ê°’ ë°˜í™˜
    const isAttacker = battle.attacker.generals.includes(generalId);
    
    if (isAttacker) {
      // ê³µê²©ì: ì§„ì…êµ¬ ê·¼ì²˜
      return { x: 20, y: 5 };
    } else {
      // ë°©ì–´ì: ê±°ì  ê·¼ì²˜
      return { x: 20, y: 30 };
    }
  }

  /**
   * ê³µê²©ì AI í–‰ë™ ìƒì„±
   * ì „ëµ: ì¤‘ì•™ ê±°ì (ê¶ì „)ìœ¼ë¡œ ì§„ê²©
   */
  private static generateAttackerAction(currentPos: { x: number; y: number }): any {
    const targetPos = { x: 20, y: 35 }; // ê¶ì „ ìœ„ì¹˜

    // ëª©í‘œ ë°©í–¥ ê³„ì‚°
    const dx = targetPos.x - currentPos.x;
    const dy = targetPos.y - currentPos.y;

    // ë‹¤ìŒ ì´ë™ ìœ„ì¹˜
    let nextX = currentPos.x;
    let nextY = currentPos.y;

    if (Math.abs(dx) > Math.abs(dy)) {
      // ì¢Œìš° ì´ë™ ìš°ì„ 
      nextX += dx > 0 ? 1 : -1;
    } else {
      // ìƒí•˜ ì´ë™ ìš°ì„ 
      nextY += dy > 0 ? 1 : -1;
    }

    // ë§µ ë²”ìœ„ ì²´í¬
    nextX = Math.max(0, Math.min(39, nextX));
    nextY = Math.max(0, Math.min(39, nextY));

    return {
      action: 'move',
      target: { x: nextX, y: nextY },
      aiGenerated: true,
    };
  }

  /**
   * ë°©ì–´ì AI í–‰ë™ ìƒì„±
   * ì „ëµ: ê±°ì  ì¤‘ì‹¬ ë°©ì–´ (ì´ë™ ìµœì†Œí™”)
   */
  private static generateDefenderAction(currentPos: { x: number; y: number }): any {
    const gatePos = { x: 20, y: 20 }; // ì„±ë¬¸ ìœ„ì¹˜

    // ì„±ë¬¸ì—ì„œ ë©€ë¦¬ ë–¨ì–´ì ¸ ìˆìœ¼ë©´ ì„±ë¬¸ìœ¼ë¡œ ì´ë™
    const distance = Math.abs(currentPos.x - gatePos.x) + Math.abs(currentPos.y - gatePos.y);

    if (distance > 5) {
      // ì„±ë¬¸ìœ¼ë¡œ ì´ë™
      const dx = gatePos.x - currentPos.x;
      const dy = gatePos.y - currentPos.y;

      let nextX = currentPos.x;
      let nextY = currentPos.y;

      if (Math.abs(dx) > Math.abs(dy)) {
        nextX += dx > 0 ? 1 : -1;
      } else {
        nextY += dy > 0 ? 1 : -1;
      }

      return {
        action: 'move',
        target: { x: nextX, y: nextY },
        aiGenerated: true,
      };
    } else {
      // ê±°ì  ê·¼ì²˜ë©´ ëŒ€ê¸°
      return {
        action: 'wait',
        aiGenerated: true,
      };
    }
  }

  /**
   * AFK ê²½ê³  ë©”ì‹œì§€ ìƒì„±
   */
  static getAFKWarningMessage(afkTurns: number): string {
    if (afkTurns === 1) {
      return 'ëª…ë ¹ì„ ì œì¶œí•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. (1í„´ AFK)';
    } else if (afkTurns === 2) {
      return 'âš ï¸ ê²½ê³ : ë‹¤ìŒ í„´ì—ë„ ëª…ë ¹ì„ ì œì¶œí•˜ì§€ ì•Šìœ¼ë©´ AIê°€ ìë™ìœ¼ë¡œ ì œì–´í•©ë‹ˆë‹¤. (2í„´ AFK)';
    } else if (afkTurns >= 3) {
      return 'ğŸ¤– AI ìë™ ì œì–´ í™œì„±í™”: ëª…ë ¹ì„ ì œì¶œí•˜ë©´ ë‹¤ì‹œ ìˆ˜ë™ ì œì–´ë¡œ ì „í™˜ë©ë‹ˆë‹¤.';
    }
    return '';
  }

  /**
   * ìœ ì € ë³µê·€ ì²˜ë¦¬
   * ëª…ë ¹ì„ ì œì¶œí•˜ë©´ AI ì œì–´ í•´ì œ
   */
  static async handleUserReturn(
    battleId: string,
    generalId: number
  ): Promise<void> {
    const battle = await (Battle as any).findOne({ battleId: battleId }).exec();
    if (!battle) return;

    const afkEntry = battle.afk_tracking.find((a) => a.general_id === generalId);
    if (afkEntry && afkEntry.ai_controlled) {
      afkEntry.ai_controlled = false;
      afkEntry.afk_turns = 0;
      await battle.save();

      console.log(`[AFK] ì¥ìˆ˜ ${generalId} ìœ ì € ë³µê·€ - AI ì œì–´ í•´ì œ`);
    }
  }

  /**
   * ì „íˆ¬ ì¢…ë£Œ ì‹œ AFK í†µê³„
   */
  static async getAFKStatistics(battleId: string): Promise<any> {
    const battle = await (Battle as any).findOne({ battleId: battleId }).exec();
    if (!battle) return null;

    const stats: Record<number, { totalAfkTurns: number; aiControlledTurns: number }> = {};

    for (const afkEntry of battle.afk_tracking) {
      stats[afkEntry.general_id] = {
        totalAfkTurns: afkEntry.afk_turns,
        aiControlledTurns: battle.turn_history.filter((h) =>
          h.actions.some(
            (a: any) => a.generalId === afkEntry.general_id && a.aiGenerated === true
          )
        ).length,
      };
    }

    return stats;
  }
}
