import { RedisService } from '../../infrastructure/cache/redis.service';
import { GameStateCache, EntityType } from '../../infrastructure/cache/game-state-cache';
import { DomesticHandler } from './handlers/patterns/domestic.handler';
import { MilitaryHandler } from './handlers/patterns/military.handler';
import { CommandType } from '../command/@types/command.types';
import fs from 'fs';
import path from 'path';

/**
 * ì»¤ë§¨ë“œ ì›Œì»¤
 * 
 * Redis Streamsì—ì„œ ì»¤ë§¨ë“œë¥¼ ì†Œë¹„í•˜ê³  ê²Œì„ ë¡œì§ ì‹¤í–‰:
 * - stream:commandsì—ì„œ ì½ê¸°
 * - GameStateCacheë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒíƒœ ë¡œë“œ
 * - íŒ¨í„´ë³„ í•¸ë“¤ëŸ¬ ì‹¤í–‰
 * - ë³€ê²½ì‚¬í•­ ìë™ ê¸°ë¡ (stream:changes)
 * - ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
 */
export class CommandWorker {
  private redis: RedisService;
  private gameCache: GameStateCache;
  private isRunning = false;
  private readonly COMMAND_STREAM = 'stream:commands';
  private readonly CONSUMER_GROUP = 'command:workers';
  private readonly CONSUMER_NAME: string;
  
  // Lua ìŠ¤í¬ë¦½íŠ¸
  private trainScript: string;
  private domesticScript: string;

  constructor() {
    this.redis = new RedisService();
    this.gameCache = new GameStateCache();
    this.CONSUMER_NAME = `worker-${process.pid}`;
    
    this.trainScript = fs.readFileSync(
      path.join(__dirname, 'scripts/train.lua'),
      'utf-8'
    );
    this.domesticScript = fs.readFileSync(
      path.join(__dirname, 'scripts/domestic.lua'),
      'utf-8'
    );
  }

  /**
   * ì›Œì»¤ ì‹œì‘
   */
  async start(): Promise<void> {
    console.log('ğŸ® ì»¤ë§¨ë“œ ì›Œì»¤ ì‹œì‘ ì¤‘...');
    
    // Consumer Group ìƒì„± (ì´ë¯¸ ì¡´ì¬í•˜ë©´ ë¬´ì‹œ)
    await this.redis.createConsumerGroup(this.COMMAND_STREAM, this.CONSUMER_GROUP);
    console.log(`âœ… Consumer Group ìƒì„± ì™„ë£Œ: ${this.CONSUMER_GROUP}`);

    this.isRunning = true;
    this.processLoop();
  }

  /**
   * ì›Œì»¤ ì¤‘ì§€
   */
  async stop(): Promise<void> {
    console.log('â¹ï¸ ì»¤ë§¨ë“œ ì›Œì»¤ ì¤‘ì§€ ì¤‘...');
    this.isRunning = false;
  }

  /**
   * ë©”ì¸ ì²˜ë¦¬ ë£¨í”„
   */
  private async processLoop(): Promise<void> {
    while (this.isRunning) {
      try {
        await this.processBatch();
      } catch (error) {
        console.error('âŒ ì»¤ë§¨ë“œ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
        await this.sleep(1000);
      }
    }
  }

  /**
   * ë°°ì¹˜ ì²˜ë¦¬
   */
  private async processBatch(): Promise<void> {
    const client = this.redis.getClient();

    // ìŠ¤íŠ¸ë¦¼ì—ì„œ ì½ê¸° (ë¸”ë¡œí‚¹, 5ì´ˆ ëŒ€ê¸°)
    const messages = await this.redis.readGroup(
      this.COMMAND_STREAM,
      this.CONSUMER_GROUP,
      this.CONSUMER_NAME,
      10, // í•œ ë²ˆì— 10ê°œì”©
      5000 // 5ì´ˆ ëŒ€ê¸°
    );

    if (messages.length === 0) {
      return;
    }

    // ê° ì»¤ë§¨ë“œ ì²˜ë¦¬
    for (const message of messages) {
      try {
        await this.processCommand(message.id, message.data);
        
        // ì²˜ë¦¬ ì™„ë£Œ í›„ ACK
        await this.redis.ack(this.COMMAND_STREAM, this.CONSUMER_GROUP, message.id);
      } catch (error) {
        console.error(`âŒ ì»¤ë§¨ë“œ ì²˜ë¦¬ ì‹¤íŒ¨ (${message.id}):`, error);
        // ì¬ì²˜ë¦¬ë¥¼ ìœ„í•´ ACKí•˜ì§€ ì•ŠìŒ
      }
    }
  }

  /**
   * ê°œë³„ ì»¤ë§¨ë“œ ì²˜ë¦¬
   */
  private async processCommand(
    streamId: string,
    data: Record<string, string>
  ): Promise<void> {
    const commandId = data.commandId;
    const commandType = data.type as CommandType;
    const generalId = data.generalId;
    const payload = JSON.parse(data.payload || '{}');
    const turn = parseInt(data.turn || '0', 10);

    console.log(`ğŸ¯ ì»¤ë§¨ë“œ ì²˜ë¦¬ ì‹œì‘: ${commandType} (${commandId})`);

    // De-dup ì²´í¬
    const dedupKey = `dedup:command:${commandId}`;
    const client = await this.redis.getClient();
    const alreadyProcessed = await client.exists(dedupKey);
    
    if (alreadyProcessed) {
      console.log(`â­ï¸ ì´ë¯¸ ì²˜ë¦¬ëœ ì»¤ë§¨ë“œ ê±´ë„ˆëœ€: ${commandId}`);
      return;
    }

    // ì»¤ë§¨ë“œ íƒ€ì…ë³„ ì²˜ë¦¬
    const handler = this.getHandler(commandType);
    
    if (!handler) {
      console.error(`âŒ ì§€ì›í•˜ì§€ ì•ŠëŠ” ì»¤ë§¨ë“œ íƒ€ì…: ${commandType}`);
      return;
    }

    // ì»¨í…ìŠ¤íŠ¸ ì¤€ë¹„
    const context = {
      commandId,
      generalId,
      type: commandType,
      payload,
      turn,
      rng: Math.random, // TODO: ì‹œë“œ ê¸°ë°˜ RNG
      generalRepo: this.createRepository(EntityType.GENERAL),
      cityRepo: this.createRepository(EntityType.CITY),
      nationRepo: this.createRepository(EntityType.NATION),
    };

    // í•¸ë“¤ëŸ¬ ì‹¤í–‰
    const result = await handler.handle(context);

    if (result.success) {
      console.log(`âœ… ${result.message}`);
    } else {
      console.error(`âŒ ì»¤ë§¨ë“œ ì‹¤í–‰ ì‹¤íŒ¨: ${result.message}`);
    }
  }

  /**
   * ì»¤ë§¨ë“œ íƒ€ì…ë³„ í•¸ë“¤ëŸ¬ ë°˜í™˜
   */
  private getHandler(type: CommandType): any {
    // ë‚´ì • ì»¤ë§¨ë“œ
    const domesticTypes = [
      CommandType.DEVELOP_AGRICULTURE,
      CommandType.INVEST_COMMERCE,
      CommandType.RESEARCH_TECH,
      CommandType.FORTIFY_DEFENSE,
      CommandType.REPAIR_WALL,
      CommandType.IMPROVE_SECURITY,
      CommandType.ENCOURAGE_SETTLEMENT,
      CommandType.GOVERN_PEOPLE,
    ];

    if (domesticTypes.includes(type)) {
      return new DomesticHandler();
    }

    // êµ°ì‚¬ ì»¤ë§¨ë“œ
    const militaryTypes = [
      CommandType.TRAIN,
      CommandType.BOOST_MORALE,
      CommandType.CONSCRIPT,
      CommandType.RECRUIT,
      CommandType.DISMISS_TROOPS,
    ];

    if (militaryTypes.includes(type)) {
      return new MilitaryHandler();
    }

    return null;
  }

  /**
   * Repository ìƒì„± (Redis ìš°ì„ )
   */
  private createRepository(type: EntityType): any {
    return {
      findById: async (id: string) => {
        return await this.gameCache.get(type, id);
      },
      update: async (id: string, changes: Record<string, any>) => {
        const entity = await this.gameCache.get(type, id);
        if (!entity) {
          throw new Error(`${type}ì„(ë¥¼) ì°¾ì„ ìˆ˜ ì—†ìŒ: ${id}`);
        }
        
        Object.assign(entity, changes);
        await this.gameCache.set(type, entity, changes);
      },
    };
  }

  /**
   * ìœ í‹¸ë¦¬í‹°: Sleep
   */
  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}
